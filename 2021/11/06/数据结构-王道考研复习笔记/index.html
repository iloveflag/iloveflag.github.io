<!DOCTYPE html>
<html lang="zh-Hans">
    <!-- title -->




<!-- keywords -->




<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="iloveflag">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="iloveflag">
    
    <meta name="keywords" content="iloveflag,iloveflag-blog">
    
    <meta name="description" content="">
    <meta name="description" content="DS2.线性表2.2 顺序表的定义顺序表的静态分配123456789101112131415161718192021&#x2F;&#x2F;顺序表 静态分配 #include &lt;stdio.h&gt;#define MaxSize 10typedef struct&#123;	ElemType data[Maxsize];	int length;&#125;Sqlist; void InitList(Sqlis">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构-王道考研复习笔记">
<meta property="og:url" content="https://iloveflag.github.io/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="iloveflag&#39;s Blog">
<meta property="og:description" content="DS2.线性表2.2 顺序表的定义顺序表的静态分配123456789101112131415161718192021&#x2F;&#x2F;顺序表 静态分配 #include &lt;stdio.h&gt;#define MaxSize 10typedef struct&#123;	ElemType data[Maxsize];	int length;&#125;Sqlist; void InitList(Sqlis">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1752423170760.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5307207219187.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1602914170771.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/4928414189197.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/3772526177064.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/2026815170772.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1659320177065.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1246926197231.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5470140210772.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1754344229198.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/3614549217065.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/2066940247231.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/2061837210863.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/3510537229289.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/54414150953.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/4021543200954.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1235959219380.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/996415190955.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1525417237413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5128121230082.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1781232197248.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/3401027209381.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/2973745217414.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/954528220083.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/4888940216638.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/3732151190959.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1919921201051.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/652348219477.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/267049207344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5036050227510.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/4339851220179.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/2318544229484.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/4645544217351.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/3793846237517.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1869848230186.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/3194549226741.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/4995447151059.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1781456169485.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5086101167352.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5979441161070.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/2758507141145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1188517169571.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5252914151146.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5240113141147.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/5669809169573.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/2771243157440.png">
<meta property="og:image" content="https://raw.githubusercontent.com/iloveflag/images/master/406053177606.png">
<meta property="article:published_time" content="2021-11-06T09:00:00.000Z">
<meta property="article:modified_time" content="2025-02-14T14:45:19.324Z">
<meta property="article:author" content="iloveflag">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/iloveflag/images/master/1752423170760.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>数据结构-王道考研复习笔记 · iloveflag&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/avatar/avatar.jpg" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="iloveflag's Blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

    
        <body class="post-body">
    
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >iloveflag-blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">数据结构-王道考研复习笔记</a>
            </div>
    </div>
    
    <a class="home-link" href=/>iloveflag-blog</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            数据结构-王道考研复习笔记
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">6.1k</span>阅读时长: <span class="post-count reading-time">29 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/11/06</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h1><h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2.线性表"></a>2.线性表</h1><h2 id="2-2-顺序表的定义"><a href="#2-2-顺序表的定义" class="headerlink" title="2.2 顺序表的定义"></a>2.2 顺序表的定义</h2><h3 id="顺序表的静态分配"><a href="#顺序表的静态分配" class="headerlink" title="顺序表的静态分配"></a>顺序表的静态分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表 静态分配 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[Maxsize];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;Sqlist; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(Sqlist &amp;L)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">		L.data[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Sqlist L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序表的动态分配"><a href="#顺序表的动态分配" class="headerlink" title="顺序表的动态分配"></a>顺序表的动态分配</h3><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/1752423170760.png" alt="内存指示图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表 动态分配 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *data;</span><br><span class="line">	<span class="type">int</span> MaxSize;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span>&#123;</span><br><span class="line">	L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	L.length=<span class="number">0</span>;</span><br><span class="line">	L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p=L.data;</span><br><span class="line">	L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		L.data[i]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L.MaxSize=L.MaxSize+len;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	SeqList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	IncreaseSize(L,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-3-顺序表的插入删除"><a href="#2-3-顺序表的插入删除" class="headerlink" title="2.3 顺序表的插入删除"></a>2.3 顺序表的插入删除</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;=MaxSize)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)&#123;</span><br><span class="line">		L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>best O(1)<br>worse O(n)<br>avg O(n)</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	e=L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)&#123;</span><br><span class="line">		L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">best <span class="title function_">O</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">worse <span class="title function_">O</span><span class="params">(n)</span></span><br><span class="line">avg <span class="title function_">O</span><span class="params">(n)</span>  </span><br><span class="line">## 2.4 顺序表的查找</span><br><span class="line">### 按位查找</span><br><span class="line">```c</span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态分配也可以使用<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/5307207219187.png" alt=""><br>ALL O(1)</p>
<h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SeqList L,ElemType e)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(L.data[i]==e)&#123;</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>best O(1)<br>worse O(n)<br>avg O(n)</p>
<h2 id="2-5-单链表的定义"><a href="#2-5-单链表的定义" class="headerlink" title="2.5 单链表的定义"></a>2.5 单链表的定义</h2><p>顺序表的优点：可随机存取，存储密度高<br>顺序表的缺点：要求大片连续空间，改变容量不方便<br>单链表的优点：不要求大片连续空间，改变容量方便<br>单链表的缺点：不可随机存取，要耗费一定空间存放指针</p>
<h3 id="常规定义"><a href="#常规定义" class="headerlink" title="常规定义"></a>常规定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span>=</span>(<span class="keyword">struct</span> LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br></pre></td></tr></table></figure>
<h3 id="书本中的定义"><a href="#书本中的定义" class="headerlink" title="书本中的定义"></a>书本中的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure><br>声明头指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LNode *L;</span><br><span class="line">LinkList L;</span><br></pre></td></tr></table></figure><br>强调这是一个单链表 —-使用LinkList<br>强调这是一个结点 —-使用LNode*</p>
<h3 id="不带头节点的单链表"><a href="#不带头节点的单链表" class="headerlink" title="不带头节点的单链表"></a>不带头节点的单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	L=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带头节点的单链表"><a href="#带头节点的单链表" class="headerlink" title="带头节点的单链表"></a>带头节点的单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	L=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-单链表的插入删除"><a href="#2-6-单链表的插入删除" class="headerlink" title="2.6 单链表的插入删除"></a>2.6 单链表的插入删除</h2><h3 id="按位序插入（带头结点）"><a href="#按位序插入（带头结点）" class="headerlink" title="按位序插入（带头结点）"></a>按位序插入（带头结点）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *p;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	p=L;</span><br><span class="line">	<span class="keyword">while</span>(p!=NUL&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>best O(1)<br>worse O(n)</p>
<h3 id="按位序插入（不带头结点）"><a href="#按位序插入（不带头结点）" class="headerlink" title="按位序插入（不带头结点）"></a>按位序插入（不带头结点）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">		LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data=e;</span><br><span class="line">		s-&gt;next=L;</span><br><span class="line">		L=s;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *p;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">	p=L;</span><br><span class="line">	<span class="keyword">while</span>(p!=NUL&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指定结点的后插操作"><a href="#指定结点的后插操作" class="headerlink" title="指定结点的后插操作"></a>指定结点的后插操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p,ElemType e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位序插入封装</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *p;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	p=L;</span><br><span class="line">	<span class="keyword">while</span>(p!=NUL&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> InsertNextNode(p,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指定结点的前插操作"><a href="#指定结点的前插操作" class="headerlink" title="指定结点的前插操作"></a>指定结点的前插操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值替换，不用去找前驱结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p,ElemType e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	s-&gt;data=p-&gt;data;</span><br><span class="line">	p-&gt;data=e;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/iloveflag/images/master/1602914170771.png" alt=""><br>O(1)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p,LNode *s)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	ElemType temp=p-&gt;data;</span><br><span class="line">	p-&gt;data=s-&gt;data;</span><br><span class="line">	s-&gt;data=temp;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/4928414189197.png" alt=""></p>
<h3 id="按位序删除（带头结点）"><a href="#按位序删除（带头结点）" class="headerlink" title="按位序删除（带头结点）"></a>按位序删除（带头结点）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *p;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	p=L;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123; <span class="comment">//i值不合法 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123; <span class="comment">//第i-1个结点之后已无其他结点 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *q=p-&gt;next;</span><br><span class="line">	e=q-&gt;next;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>avg worse O(n)<br>best O(1)</p>
<h3 id="指定结点的删除"><a href="#指定结点的删除" class="headerlink" title="指定结点的删除"></a>指定结点的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *q=p-&gt;next;</span><br><span class="line">	p-&gt;data=p-&gt;next-&gt;data;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/iloveflag/images/master/3772526177064.png" alt=""><br>O(1)<br><strong>如果p是最后一个结点，只能从表头开始依次寻找p的前驱，时间复杂度O(n)</strong></p>
<h2 id="2-7-单链表的查找"><a href="#2-7-单链表的查找" class="headerlink" title="2.7 单链表的查找"></a>2.7 单链表的查找</h2><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *p;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	p=L;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>avg O(n)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//王道书版本</span></span><br><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>avg O(n)</p>
<h3 id="求表的长度"><a href="#求表的长度" class="headerlink" title="求表的长度"></a>求表的长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">	LNode *p=L;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-8-单链表的建立"><a href="#2-8-单链表的建立" class="headerlink" title="2.8 单链表的建立"></a>2.8 单链表的建立</h4><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	LNode *s,*r=L; <span class="comment">//r为表尾指针</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">		s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data=x;</span><br><span class="line">		r-&gt;next=s;</span><br><span class="line">		r=s;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O(n)</p>
<h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	LNode *s;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//很重要</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">		s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data=x;</span><br><span class="line">		s-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=s;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重要应用：链表的逆置</strong></p>
<h2 id="2-9-双链表"><a href="#2-9-双链表" class="headerlink" title="2.9 双链表"></a>2.9 双链表</h2><h3 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">	L=(DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;prior=<span class="literal">NULL</span>; <span class="comment">//NULL forever</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">	DLinklist L;</span><br><span class="line">	InitDLinkList(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链表的插入"><a href="#双链表的插入" class="headerlink" title="双链表的插入"></a>双链表的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;next=p-&gt;next; <span class="comment">//step 1</span></span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		p-&gt;next-&gt;prior=s; <span class="comment">//step2</span></span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;prior=p; <span class="comment">//step3</span></span><br><span class="line">	p-&gt;next=s; <span class="comment">//step4</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/iloveflag/images/master/2026815170772.png" alt=""><br>p没有后继结点：<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/1659320177065.png" alt=""></p>
<h3 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	DNode *q=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		q-&gt;next-&gt;prior=p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/iloveflag/images/master/1246926197231.png" alt=""></p>
<h3 id="双链表的销毁"><a href="#双链表的销毁" class="headerlink" title="双链表的销毁"></a>双链表的销毁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(L-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		DeleteNextDNode(L);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(L);</span><br><span class="line">	L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链表的遍历"><a href="#双链表的遍历" class="headerlink" title="双链表的遍历"></a>双链表的遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">	p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">	p=p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;prior!=<span class="literal">NULL</span>)&#123; <span class="comment">//跳过头结点</span></span><br><span class="line">	p=p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双链表不可随机存取，按位查找，按值查找操作都只能用遍历的方式实现O(n)</strong></p>
<h2 id="2-10-循环列表"><a href="#2-10-循环列表" class="headerlink" title="2.10 循环列表"></a>2.10 循环列表</h2><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	L=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;next=L;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L )</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next==L)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==L)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">	L=(DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;prior=L;</span><br><span class="line">	L-&gt;next=L;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testDlinkList</span><span class="params">()</span>&#123;</span><br><span class="line">	DLinklist L;</span><br><span class="line">	InitDLinkList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next==L)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(DLinklist L,DNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==L)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环双链表的插入"><a href="#循环双链表的插入" class="headerlink" title="循环双链表的插入"></a>循环双链表的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span>&#123;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next-&gt;piror=s; <span class="comment">//step2</span></span><br><span class="line">	s-&gt;piror=p;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>step2 compare to <a href="#双链表的插入">#双链表的插入</a></strong><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/5470140210772.png" alt=""></p>
<h3 id="循环双链表的删除"><a href="#循环双链表的删除" class="headerlink" title="循环双链表的删除"></a>循环双链表的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	DNode *q=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	q-&gt;next-&gt;prior=p;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>step2 compare to <a href="#双链表的删除">#双链表的删除</a></strong><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/1754344229198.png" alt=""></p>
<h2 id="2-11-静态链表"><a href="#2-11-静态链表" class="headerlink" title="2.11 静态链表"></a>2.11 静态链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/3614549217065.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>课本上的定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure><br>等价于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br></pre></td></tr></table></figure><br>注解:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">	SLinkList a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>等价于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自己验证一下吧！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">x</span>;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeX=%d\n&quot;</span>,<span class="keyword">sizeof</span>(x));</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeA=%d\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	</span><br><span class="line">	SLinkList b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof=%d\n&quot;</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/2066940247231.png" alt=""></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从头结点出发挨个往后遍历结点 O(n)</p>
<h3 id="插入位序为i的结点"><a href="#插入位序为i的结点" class="headerlink" title="插入位序为i的结点"></a>插入位序为i的结点</h3><p>1.找到一个空的结点，存入数据元素<br>2.从头结点出发找到位序为i-1的结点<br>3.修改新节点的next<br>4.修改i-1号结点的next</p>
<h3 id="删除某个结点"><a href="#删除某个结点" class="headerlink" title="删除某个结点"></a>删除某个结点</h3><p>1.从头结点出发找到前驱结点<br>2.修改前驱结点的游标<br>3.被删除结点next设为-2(空)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态链表:用数组的方式实现的链表<br>优点:增,删操作不需要大量移动元素<br>缺点:不能随机存取，只能从头结点开始依次往后查<br>找:<strong>容量固定不可变</strong><br>适用场景:<br>1.不支持指针的低级语言<br>2.数据元素数量固定不变的场景(如操作系统的文件分配表FAT)</p>
<h2 id="2-12-顺序表和链表的比较"><a href="#2-12-顺序表和链表的比较" class="headerlink" title="2.12 顺序表和链表的比较"></a>2.12 顺序表和链表的比较</h2><h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3.栈和队列"></a>3.栈和队列</h1><h2 id="3-1-栈的基本概念"><a href="#3-1-栈的基本概念" class="headerlink" title="3.1 栈的基本概念"></a>3.1 栈的基本概念</h2><p>栈是<strong>只允许在一端进行插入和删除操作</strong>的线性表<br>特点:后进先出 Last First Out （LIFO)<br>n个不同元素进栈，出栈元素不同排列的个数为<script type="math/tex">\frac{1}{n+1} C_{n}^{2n}</script>，上述公式称为卡特兰(Catalan )数(不要求掌握)</p>
<h2 id="3-2-栈的顺序存储结构"><a href="#3-2-栈的顺序存储结构" class="headerlink" title="3.2 栈的顺序存储结构"></a>3.2 栈的顺序存储结构</h2><h3 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> top;  <span class="comment">//栈顶指针 </span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">	S.top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	InitStack(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	S.top=S.top+<span class="number">1</span>;</span><br><span class="line">	S.data[S.top]=x;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S.top=S.top+<span class="number">1</span>;</span><br><span class="line">S.data[S.top]=x;</span><br><span class="line">等价于</span><br><span class="line">S.data[++S.top]=x;</span><br></pre></td></tr></table></figure>
<h3 id="出栈操作"><a href="#出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x=S.data[S.top];</span><br><span class="line">	S.top=S.top<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=S.data[S.top];</span><br><span class="line">S.top=S.top<span class="number">-1</span>;</span><br><span class="line">等价于</span><br><span class="line">x=S.data[S.top--];</span><br></pre></td></tr></table></figure>
<h3 id="读栈顶元素操作"><a href="#读栈顶元素操作" class="headerlink" title="读栈顶元素操作"></a>读栈顶元素操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x=S.data[S.top];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">	S.top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S.data[S.top++]=x;</span><br><span class="line">x=S.data[--S.top];</span><br><span class="line">top==MaxSize</span><br></pre></td></tr></table></figure></p>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> top0;</span><br><span class="line">	<span class="type">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">	S.top0=<span class="number">-1</span>;</span><br><span class="line">	S.top1=MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Stackfull</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top0+<span class="number">1</span>==top1)&#123;</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-栈的链式存储结构"><a href="#3-3-栈的链式存储结构" class="headerlink" title="3.3 栈的链式存储结构"></a>3.3 栈的链式存储结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure>
<p><strong>根据复习单链表不带头结点的操作</strong></p>
<h2 id="3-4-列队的基本概念"><a href="#3-4-列队的基本概念" class="headerlink" title="3.4 列队的基本概念"></a>3.4 列队的基本概念</h2><p>队列是<strong>只允许在一端进行插入，在另一端删除</strong>的线性表<br>队列的特点:先进先出First In First Out(FIFO)</p>
<h2 id="3-5-列队的顺序存储结构"><a href="#3-5-列队的顺序存储结构" class="headerlink" title="3.5 列队的顺序存储结构"></a>3.5 列队的顺序存储结构</h2><h3 id="队列的顺序实现"><a href="#队列的顺序实现" class="headerlink" title="队列的顺序实现"></a>队列的顺序实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">	Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	SqQueue Q;</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Q.data[Q.rear]=x;</span><br><span class="line">	Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x=Q.data[Q.front];</span><br><span class="line">	Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x=Q.data[Q.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队列状态"><a href="#判断队列状态" class="headerlink" title="判断队列状态"></a>判断队列状态</h3><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>队列已满:<br><code>(Q.rear+1)%MaxSize==Q.front</code><br>队空:<br><code>Q.rear==Q.front</code><br><strong>队列元素的个数:</strong><br><strong><code>(rear+MaxSize-front)%MaxSize</code></strong></p>
<h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front,rear;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>插入<code>size++;</code><br>删除<code>size--;</code><br>队满<code>size==MaxSize;</code><br>队空<code>size==0;</code></p>
<h4 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front,rear;</span><br><span class="line">	<span class="type">int</span> tag; <span class="comment">//最近进行的是删除0/插入1</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>队满:<code>front==rear&amp;&amp;tag==1</code><br>队空:<code>front==rear&amp;&amp;tag==0</code></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>rear指向队尾元素<br>入队:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">Q.data[Q.rear]=x;</span><br></pre></td></tr></table></figure><br>初始化:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front=<span class="number">0</span>；</span><br><span class="line">rear=n<span class="number">-1</span>；</span><br></pre></td></tr></table></figure><br>队空：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Q.rear+<span class="number">1</span>]%MaxSize==Q.front;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/2061837210863.png" alt=""><br>队满：<br>法1:牺牲一个存储单元<br>法2:增加一个辅助变量<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/3510537229289.png" alt=""></p>
<h2 id="3-6-列队的链式存储结构"><a href="#3-6-列队的链式存储结构" class="headerlink" title="3.6 列队的链式存储结构"></a>3.6 列队的链式存储结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<h3 id="初始化-带头结点"><a href="#初始化-带头结点" class="headerlink" title="初始化(带头结点)"></a>初始化(带头结点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">	Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化-不带头结点"><a href="#初始化-不带头结点" class="headerlink" title="初始化(不带头结点)"></a>初始化(不带头结点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">	Q.front=<span class="literal">NULL</span>;</span><br><span class="line">	Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队-带头结点"><a href="#入队-带头结点" class="headerlink" title="入队(带头结点)"></a>入队(带头结点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">	LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">	s-&gt;data=x;</span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next=s;</span><br><span class="line">	Q.rear=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队-不带头结点"><a href="#入队-不带头结点" class="headerlink" title="入队(不带头结点)"></a>入队(不带头结点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class="line">	LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">	s-&gt;data=x;</span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		Q.front=s;</span><br><span class="line">		Q.rear;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		Q.rear-&gt;next=s;</span><br><span class="line">		Q.rear=s;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队-带头结点"><a href="#出队-带头结点" class="headerlink" title="出队(带头结点)"></a>出队(带头结点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q.front)==Q.rear)&#123;</span><br><span class="line">		<span class="keyword">return</span> fasle;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkNode *p=Q.front-&gt;next;</span><br><span class="line">	x=p-&gt;data;</span><br><span class="line">	Q.front-&gt;next=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)&#123;</span><br><span class="line">		Q.rear=Q.front;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队-不带头结点"><a href="#出队-不带头结点" class="headerlink" title="出队(不带头结点)"></a>出队(不带头结点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkNode *p=Q.front;</span><br><span class="line">	x=p-&gt;data;</span><br><span class="line">	Q.front=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)&#123;</span><br><span class="line">	   Q.front=<span class="literal">NULL</span>;</span><br><span class="line">		Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7-双端队列"><a href="#3-7-双端队列" class="headerlink" title="3.7 双端队列"></a>3.7 双端队列</h2><p><strong>双端队列</strong>:允许从两端插入，两端删除的队列<br><strong>输入受限的双端队列</strong>:允许从两端删除，从一端插入的队列<br><strong>输出受限的双端队列</strong>:允许从两端插入，从一端删除的队列<br><strong>考点</strong>:判断输出序列合法性</p>
<h2 id="3-8-栈在括号匹配中的应用"><a href="#3-8-栈在括号匹配中的应用" class="headerlink" title="3.8 栈在括号匹配中的应用"></a>3.8 栈在括号匹配中的应用</h2><p>遇到左括号就入栈<br>遇到右括号,就”消耗”一个左括号<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10 <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data[MaxSize]; <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">	<span class="type">int</span> top; </span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空 </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈 </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">char</span> x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶元素出栈.用x返回 </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">char</span> &amp;x)</span> </span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	InitStack(S); <span class="comment">//初始化一个栈</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i]==<span class="string">&#x27;(&#x27;</span> || str[i]==<span class="string">&#x27;[&#x27;</span> || str[i]==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">			Push(S,str[i]);  <span class="comment">//扫描到左括号,入栈 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(StackEmpty(S))&#123; <span class="comment">//扫描到右括号,且当前栈空 </span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//匹配失败 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">char</span> topElem;</span><br><span class="line">			Pop(S,topElem); <span class="comment">//栈顶元素出栈 </span></span><br><span class="line">			<span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp; topElem!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(str[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp; topElem!=<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(str[i]==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; topElem!=<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;							</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> StackEmpty(S);  <span class="comment">//检索完全部括号后,栈空说明匹配成功 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/54414150953.png" alt=""><br><strong>用栈实现括号匹配</strong>: 依次扫描所有字符,遇到左括号入栈,遇到右括号则弹出栈顶元素检查是否匹配<br><strong>匹配失败情况</strong>: 1.左括号单身 2.右括号单身 3.左右括号不匹配</p>
<h2 id="3-9-栈在表达式求值中的应用（上）-后缀为重点"><a href="#3-9-栈在表达式求值中的应用（上）-后缀为重点" class="headerlink" title="3.9 栈在表达式求值中的应用（上）(后缀为重点)"></a>3.9 栈在表达式求值中的应用（上）(后缀为重点)</h2><p>Reverse Polish notation (逆波兰表达式=后缀表达式)<br>Polish natation(波兰表达式=前缀表达式)<br>中缀表达式:运算符在两个操作数中间<br>后缀表达式:运算符在两个操作数后面<br>前缀表达式:运算符在两个操作数前面<br>例子:<br>| 中缀表达式    |  后缀表达式   | 前缀表达式     |<br>| —- | —- | —- |<br>|   a+b  |  ab+   |   +ab  |<br>|  a+b-c    |  ab+c-   |   -+abc |<br>|   a+b-c*d  |   ab+cd*-  | -+ab cd*   |</p>
<h3 id="中缀表达式转后缀表达式-手算"><a href="#中缀表达式转后缀表达式-手算" class="headerlink" title="中缀表达式转后缀表达式(手算):"></a>中缀表达式转后缀表达式(手算):</h3><p>1.确定中缀表达式中各个运算符的运算顺序<br>2.选择下一个运算符,按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数<br>3.如果还有运算符没被处理,就继续2<br>如:<br>    ((15÷(7-(1+1)))×3)-(2+(1+1))<br> =&gt;     15 7 1 1 + - ÷    2 1 1+ +  -<br>        A+B*(C-D)-E/F<br>=&gt;     AB CD-*+   EF/ -  或 ABCD-*  EF/ -+ (<strong>客观来看两种都正确,只是”机算”结果是前者</strong>)<br>       运算顺序不唯一,因此对应的后缀表达式也不唯一<br>       “左优先”原则,不要freestyle,保证手算和机算结果相同<br>       “左优先”原则:只要左边的运算符能先计算,就优先算左边的(可保证运算服务顺序唯一)<br>       A+B-C*D/E+F<br>=&gt;       AB+CD*E/-F+</p>
<h3 id="后缀表达式的计算-手算"><a href="#后缀表达式的计算-手算" class="headerlink" title="后缀表达式的计算(手算)"></a>后缀表达式的计算(手算)</h3><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/4021543200954.png" alt=""><br>后缀表达式的手算方法:<br>从左往右扫描,每遇到一个运算符,就让运算符前面最近的两个操作数执行对应运算.<br>合体为一个操作数<br>注意:两个操作数的左右顺序<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/1235959219380.png" alt=""></p>
<h3 id="后缀表达式的计算-机算"><a href="#后缀表达式的计算-机算" class="headerlink" title="后缀表达式的计算(机算)"></a>后缀表达式的计算(机算)</h3><p>用栈实现后缀表达式的计算<br>1.<mark>从左往右</mark>扫描下一个元素,直到处理完所有元素<br>2.若扫描到操作数则压入栈,并回到1;否则执行3<br>3.若扫描到运算符,则弹出两个栈顶元素,执行相应运算,运算结果压倒栈顶,回到1<br><strong>注意:先出栈的是”右操作数”</strong><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/996415190955.gif" alt="1"></p>
<p>若表达式合法,则最后栈中只会留下一个元素,就是最终结果<br>练习题;<br>15 7 1 1 + - ÷ 3 × 2 1 1 + + -<br>答案:5</p>
<h3 id="中缀表达式转前缀表达式-手算"><a href="#中缀表达式转前缀表达式-手算" class="headerlink" title="中缀表达式转前缀表达式(手算)"></a>中缀表达式转前缀表达式(手算)</h3><p>中缀转前缀的手算方法:<br>1.确定中缀表达式中各个运算符的运算顺序<br>2.选择下一个运算符,按照[运算符 左操作数 右操作数]的方式组合成一个新的操作数<br>3.如果还有运算符没被处理,就继续2<br>“右优先”原则:只要右边的运算符能先计算,就优先算右边的<br>A+B*(C-D)-E/F<br>=&gt; - +A<em>B-CD  /EF 或 +A-\</em>B-CD/EF<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/1525417237413.png" alt=""></p>
<h3 id="前缀表达式的计算"><a href="#前缀表达式的计算" class="headerlink" title="前缀表达式的计算"></a>前缀表达式的计算</h3><p>用栈实现前缀表达式的计算<br>1.从右往左扫描下一个元素,直到处理完所有元素<br>2.若扫描到操作数则压入栈,并回到1;否则执行3<br>3.若扫描到运算符,则弹出两个栈顶元素,执行相应运算,运算结果压回栈顶,回到1<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/5128121230082.png" alt=""><br><strong>注意:先出栈的是”左操作数”</strong></p>
<h2 id="3-10-栈在表达式求值中的应用（下）"><a href="#3-10-栈在表达式求值中的应用（下）" class="headerlink" title="3.10 栈在表达式求值中的应用（下）"></a>3.10 栈在表达式求值中的应用（下）</h2><h3 id="中缀表达式转后缀表达式-机算"><a href="#中缀表达式转后缀表达式-机算" class="headerlink" title="中缀表达式转后缀表达式(机算)"></a>中缀表达式转后缀表达式(机算)</h3><p>初始化一个栈,用于保存<mark>暂时还不能确定运算顺序的运算符</mark>.<br>从左到右处理各个元素,直到末尾.可能遇到三种情况:<br>1.遇到<mark>操作数</mark>.直接加入后缀表达式<br>2.遇到<mark>界限符</mark>.遇到”(“直接入栈;遇到”)”则依次弹出栈内运算符并加入后缀表达式,<br>3.遇到<mark>运算符</mark>.依次弹出栈中<mark>优先级</mark>高于或等于当前运算符的所有运算符,并加入后缀表达式,<br>若碰到”(“或栈空则停止.之后再把当前运算符入栈.<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/1781232197248.gif" alt="3"><br>按上述方法处理完所有字符后,将栈中剩余运算符依次弹出,并加入后缀表达式</p>
<h3 id="中缀表达式的计算-用栈实现"><a href="#中缀表达式的计算-用栈实现" class="headerlink" title="中缀表达式的计算(用栈实现)"></a>中缀表达式的计算(用栈实现)</h3><p><strong>中缀转后缀+后缀表达式求值 两个算法的结合</strong><br>用栈实现中缀表达式的计算:<br>初始化两个栈,操作数栈和运算符栈<br>若扫描到操作数,压入操作数栈<br>若扫描到运算符或界限符,则按照”中缀转后缀”相同的逻辑压入运算符栈(期间也会<mark>弹出</mark><br>运算符,<mark>每当弹出一个运算符时,就需要再弹出两个操作数栈的栈顶元素并执行相应运算,运算结果再压回操作数栈</mark>)<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/3401027209381.gif" alt="2"></p>
<h2 id="3-11-栈在递归中的应用"><a href="#3-11-栈在递归中的应用" class="headerlink" title="3.11 栈在递归中的应用"></a>3.11 栈在递归中的应用</h2><p>函数调用的特点:最后被调用的函数最先执行结束(LIFO)<br>函数调用时,需要用一个栈存储:<br>1.调用返回地址<br>2.实参<br>3.局部变量<br>适合用”递归”算法解决:可以把原始问题转换为<mark>属性相同</mark>,但<mark>规模较小</mark>的问题<br>Eg1: 计算正整数的阶层n!<br>Eg2:求斐波那契数列<br>递归调用时,函数调用栈可称为”递归工作栈”<br>每进入一层递归,就将递归调用所需信息压入栈顶<br>每退出一层递归,就从栈顶弹出相应信息<br>缺点:太多层递归可能会导致栈溢出<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/2973745217414.png" alt=""><br>缺点:可能包含很多重复计算</p>
<h2 id="3-12-队列的应用"><a href="#3-12-队列的应用" class="headerlink" title="3.12 队列的应用"></a>3.12 队列的应用</h2><p>树的层次遍历<br>图的广度优先遍历<br>在操作系统中的应用:多个进程争抢着使用有限的系统资源时,FCFS(First Come First Service,先来先服务)是一种常用策略.<br>Eg:打印数据缓冲区</p>
<h2 id="3-13-特殊矩阵的压缩存储"><a href="#3-13-特殊矩阵的压缩存储" class="headerlink" title="3.13 特殊矩阵的压缩存储"></a>3.13 特殊矩阵的压缩存储</h2><h3 id="一维数组的存储结构"><a href="#一维数组的存储结构" class="headerlink" title="一维数组的存储结构"></a>一维数组的存储结构</h3><p>ElemType a[10];<br>起始地址:LOC<br>各数组元素大小相同,且物理上连续存放.<br>数组元素a[i]的存放地址=LOC+i*sizeof(EleType)<br>注:除非题目特别说明,否则数组下标默认从0开始</p>
<h3 id="二维数组的存储结构"><a href="#二维数组的存储结构" class="headerlink" title="二维数组的存储结构"></a>二维数组的存储结构</h3><p>ElemType b[2][4];<br>行优先存储或者列优先存储<br>M行N列的二维数组b[M][N]中,<br>若按行优先存储,则<br>b[i][j]的存储地址=LOC+(i<em>N+j)\</em>sizesof(ElemType)</p>
<p>若按列优先存储,则<br>b[i][j]的存储地址=LOC+(j<em>M+i)\</em>sizesof(ElemType)</p>
<h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><p>可用二维数组存储</p>
<h3 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h3><p>策略:只存储主对角线+下三角区<br>按行优先原则将各元素存入一维数组中<br>数组大小应为(1+n)*n/2<br>关于矩阵下标和一维数组下标的映射:<br>问按照行优先的原则,ai,j 是<mark>第</mark>(1+i)i/2+j<mark>个元素</mark><br>按照列优先的原则是[[n+(n-1)+…+(n-j+2)]+(i-j)+1]</p>
<h3 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h3><p>压缩存储策略:按行优先原则将橙色区元素存入一维数组中.并在最后一个位置存储常量c<br>下三角矩阵:按照行优先的原则,是<mark>B[0]B[k]开始 k=</mark>(1+i)i/2+j-1 ,上三角区域都是(1+n)n/2<br>上三角矩阵:按照行优先的原则,是<mark>B[0]B[k]开始 k=</mark>(n+(n-1)+…+(n-i+2))+(j-i) ,下三角区域都是(1+n)n/2</p>
<h3 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h3><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/954528220083.png" alt=""><br>一共需要存储3*n-2个元素</p>
<p>前i-1行共3(i-1)-1个元素<br>ai,j是i行第j-i+2个元素<br>ai,j是第2i+j-2个元素,k=2i+j-3</p>
<p>反问:若已知数组下标k,如何得到i,j?<br>第k+1个元素,在第几行?第几列?<br>前i-1行共3(i-1)-1个元素<br>前i行共3i-1个元素<br>显然,3(i-1)-1<k+1<=3i-1
i>=(k+2)/3  =&gt; i=⌈(k+2)/3⌉ (向上取整符号)<br>由k=2i+j-3得j<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/4888940216638.png" alt=""></p>
<h3 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h3><p>稀疏矩阵:非零元素远远少于矩阵元素的个数<br>压缩存储策略:<br>顺序存储—三元组&lt;行,列,值&gt;<br>链式存储—十字链表法</p>
<h1 id="4-串"><a href="#4-串" class="headerlink" title="4.串"></a>4.串</h1><h2 id="4-1-串的定义和基本操作"><a href="#4-1-串的定义和基本操作" class="headerlink" title="4.1 串的定义和基本操作"></a>4.1 串的定义和基本操作</h2><h2 id="4-2-串的存储结构"><a href="#4-2-串的存储结构" class="headerlink" title="4.2 串的存储结构"></a>4.2 串的存储结构</h2><h3 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255  <span class="comment">//预定义最长串为255 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> ch[MAXLEN];  <span class="comment">//每个分量存储一个字符 </span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//串的实际长度 </span></span><br><span class="line">&#125;SString;  </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> *ch;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">HString S;</span><br><span class="line">S.ch=(<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">S.length=<span class="number">0</span>; </span><br></pre></td></tr></table></figure>
<h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> ch; <span class="comment">//每个结点存1个字符  1B</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span>  <span class="comment">//4B</span></span><br><span class="line">&#125;StringNode,* String;</span><br></pre></td></tr></table></figure>
<p>存储密度低,每个字符1B,每个指针4B<br>解决方案:每个结点存多个字符<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> ch[<span class="number">4</span>]; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span>  <span class="comment">//4B</span></span><br><span class="line">&#125;StringNode,* String;</span><br></pre></td></tr></table></figure></p>
<h3 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255  <span class="comment">//预定义最长串为255 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> ch[MAXLEN];  <span class="comment">//每个分量存储一个字符 </span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//串的实际长度 </span></span><br><span class="line">&#125;SString;  </span><br><span class="line"></span><br><span class="line">S.ch =<span class="string">&quot;wangdao&quot;</span></span><br><span class="line">S.length=<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> SubString(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos+len<span class="number">-1</span>&gt;S.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;pos+len;i++)&#123;</span><br><span class="line">		Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	Sub.length = len;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S.ch =<span class="string">&quot;wangdao&quot;</span></span><br><span class="line">S.length=<span class="number">7</span></span><br><span class="line"><span class="type">int</span> StrCompare(SString S,SSting T)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;S.length&amp;&amp;i&lt;T.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(S.ch[i]!=T.ch[i])&#123;</span><br><span class="line">			<span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//扫描过的所有字符都相同,则长度长的串更大 </span></span><br><span class="line">	<span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定位操作"><a href="#定位操作" class="headerlink" title="定位操作"></a>定位操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>,n=StrLength(S),m=StrLength(T);</span><br><span class="line">	SString sub;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">		SubString(sub,S,i,m);</span><br><span class="line">		<span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>) ++i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="4-3-朴素模式匹配算法"><a href="#4-3-朴素模式匹配算法" class="headerlink" title="4.3 朴素模式匹配算法"></a>4.3 朴素模式匹配算法</h2><p>主串长度为n,模式串长度为m<br>朴素模式匹配算法:将主串中所有长度为m的子串依次与模式串对比,直到找到一个完全匹配的子串,<br>或所有的子串都不匹配为止<br>暴力解法,最多对比n-m+1个子串<br>代码1就是<a href="#定位操作">#定位操作</a><br>代码2指针定位算法:<br>若当前子串匹配模式失败,则主串指针i指向下一个子串的第一个位置,模式串指针j回到 模式串的第一个位置<br>若j&gt;T.length,则当前子串匹配成功,返回当前子串第一个字符的位置— <mark>i-T.length</mark><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>;j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">		<span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">			++i;++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			i=i-j+<span class="number">2</span>;</span><br><span class="line">			j=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j&gt;T.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> i-T.length;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>最坏时间复杂度O(nm)<br>最好时间复杂度O(m)或O(1)</p>
<h2 id="4-4-KMP算法"><a href="#4-4-KMP算法" class="headerlink" title="4.4 KMP算法"></a>4.4 KMP算法</h2><p>不匹配的字符之前,一定是和模式串一致的<br>对于模式串T = ‘abaabc’<br>当<mark>第6个</mark>元素匹配失败时，可令主串指针<mark>i不变</mark>，模式串指针<mark>j=3</mark><br>当<mark>第5个</mark>元素匹配失败时，可令主串指针<mark>i不变</mark>，模式串指针<mark>j=2</mark><br>当<mark>第4个</mark>元素匹配失败时，可令主串指针<mark>i不变</mark>，模式串指针<mark>j=2</mark><br>当<mark>第3个</mark>元素匹配失败时，可令主串指针<mark>i不变</mark>，模式串指针<mark>j=1</mark><br>当<mark>第2个</mark>元素匹配失败时，可令主串指针<mark>i不变</mark>，模式串指针<mark>j=1</mark><br>当<mark>第1个</mark>元素匹配失败时，匹配下-个相邻子串，令<mark>j=0, i++, j++</mark><br>引入next数组来定位j去改变j的值</p>
<p>算法思路:根据模式串T,求出next数组 =&gt; 利用next数组进行匹配(主串指针不回溯)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;T.length)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">0</span>||S.ch[i]==T.ch[j])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			j=next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j&gt;T.length)&#123;</span><br><span class="line">		<span class="keyword">return</span> i-T.length;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最坏时间复杂度O(m+n)<br>其中,求next数组时间复杂度O(m)</p>
<h2 id="4-5-求next数组"><a href="#4-5-求next数组" class="headerlink" title="4.5 求next数组"></a>4.5 求next数组</h2><p>任何模式串都一样<br>第一个字符不匹配时,只能匹配下一个子串,因此,往后余生,<mark>next[1]都无脑写0</mark><br>第二个字符不匹配时,应尝试匹配模式串的第2个字符,因此,往后余生,<mark>next[2]都无脑写1</mark><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/3732151190959.gif" alt="4"></p>
<h1 id="5-二叉树"><a href="#5-二叉树" class="headerlink" title="5.二叉树"></a>5.二叉树</h1><h2 id="5-5-二叉树的存储结构"><a href="#5-5-二叉树的存储结构" class="headerlink" title="5.5 二叉树的存储结构"></a>5.5 二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">	ElemType value;</span><br><span class="line">	<span class="type">bool</span> isEmpty;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];</span><br></pre></td></tr></table></figure>
<p>结论:二叉树的顺序存储结构，只适合存储完全二叉树</p>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ElemType</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line">BiTree root=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">root =(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BiTNode *p=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data=&#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild=p; </span><br></pre></td></tr></table></figure>
<p>n个结点的二叉链表共有n+1个空链域</p>
<h2 id="5-6-二叉树的先中后序遍历"><a href="#5-6-二叉树的先中后序遍历" class="headerlink" title="5.6 二叉树的先中后序遍历"></a>5.6 二叉树的先中后序遍历</h2><p>先序遍历:根左右(NLR)<br>中序遍历左根右(LNR)<br>后序遍历:左右根(LRN)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		visit(T);</span><br><span class="line">		PreOrder(T-&gt;Lchild);</span><br><span class="line">		preOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		InOrder(T-&gt;Lchild);</span><br><span class="line">		visit(T);</span><br><span class="line">		InOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		PostOrder(T-&gt;Lchild);</span><br><span class="line">		PostOrder(T-&gt;rchild);</span><br><span class="line">		visit(T);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>O(n)</p>
<h2 id="5-7-二叉树的层次遍历"><a href="#5-7-二叉树的层次遍历" class="headerlink" title="5.7 二叉树的层次遍历"></a>5.7 二叉树的层次遍历</h2><p>算法思想:<br>1.初始化一个辅助队列<br>2.根节点入队<br>3.若队列非空，则队头结点出队，访问该结点，并将其左,右孩子插入队尾(如果有的话)<br>4.重复3直至队列为空<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储) </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">	BiTNode * data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	LinkNode *front,*rear; <span class="comment">//队头,队尾 </span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">	BiTree p;</span><br><span class="line">	EnQueue(Q,T);     <span class="comment">//将根结点入队 </span></span><br><span class="line">	<span class="keyword">while</span>(!isEmpty(Q))&#123;   <span class="comment">//队列不空则循环 </span></span><br><span class="line">		DeQueue(Q,p);     <span class="comment">//队头结点出队 </span></span><br><span class="line">		visit(p);             <span class="comment">//访问出队结点 </span></span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			EnQueQue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="5-8-由遍历序列构造二叉树"><a href="#5-8-由遍历序列构造二叉树" class="headerlink" title="5.8 由遍历序列构造二叉树"></a>5.8 由遍历序列构造二叉树</h2><p>结论:若只给出一棵二叉树的前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树</p>
<p>可以确定的二叉树:<br>前序+中序遍历序列:<br>-&gt;根节点从前往后分析<br>后序+中序遍历序列:<br>-&gt;根节点从后往前分析<br>层序+中序遍历序列:<br>-&gt;根节点 左子树的根 右子树的根</p>
<h2 id="5-9-线索二叉树的概念"><a href="#5-9-线索二叉树的概念" class="headerlink" title="5.9 线索二叉树的概念"></a>5.9 线索二叉树的概念</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">	<span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree; </span><br></pre></td></tr></table></figure>
<p>tag==0,表示指针指向孩子<br>tag==1，表示指针是”线索”<br>n个结点的二叉树，有n+1个空链域!可用来记录前驱，后继的信息</p>
<h2 id="5-10-二叉树的线索化"><a href="#5-10-二叉树的线索化" class="headerlink" title="5.10 二叉树的线索化"></a>5.10 二叉树的线索化</h2><h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用土办法找中序前驱</span></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		InOrder(T-&gt;lchild);</span><br><span class="line">		visit(T);</span><br><span class="line">		InOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode * q)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(q==p)&#123;</span><br><span class="line">		final = pre;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		pre=q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">BiTNode *p;</span><br><span class="line">BiTNode * pre=<span class="literal">NULL</span>;</span><br><span class="line">BiTNode * final=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">	<span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,* ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		InThread(T-&gt;lchild);</span><br><span class="line">		visit(T);</span><br><span class="line">		InTread(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vist</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		q-&gt;lchild=pre;</span><br><span class="line">		q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		pre-&gt;rchild=q;</span><br><span class="line">		pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pre=q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">	pre=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		InThread(T);</span><br><span class="line">		<span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			pre-&gt;rtag=<span class="number">1</span>;   <span class="comment">//处理最后一个结点 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ThreadNode *pre=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h3><p>防止循环问题<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		visit(T);</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;ltag==<span class="number">0</span>)&#123; <span class="comment">//lchild不是前驱线索</span></span><br><span class="line">			PreThread(T-&gt;lchild); </span><br><span class="line">		&#125; </span><br><span class="line">		PreThread(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h3><p>不会出现循环问题<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		PostThread(T-&gt;lchild);</span><br><span class="line">		PostThread(T-&gt;rchild);</span><br><span class="line">		visit(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-11-在线索二叉树中找前驱后继"><a href="#5-11-在线索二叉树中找前驱后继" class="headerlink" title="5.11 在线索二叉树中找前驱后继"></a>5.11 在线索二叉树中找前驱后继</h2><h3 id="中序线索二叉树中找中序后继"><a href="#中序线索二叉树中找中序后继" class="headerlink" title="中序线索二叉树中找中序后继"></a>中序线索二叉树中找中序后继</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>) p=p-&gt;lchild;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">//在中序线索二叉树中找到结点P的后继结点 </span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>) <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ThreadNode *p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))&#123;</span><br><span class="line">		visit(p);</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>O(1)</p>
<h3 id="中序线索二叉树中找中序前驱"><a href="#中序线索二叉树中找中序前驱" class="headerlink" title="中序线索二叉树中找中序前驱"></a>中序线索二叉树中找中序前驱</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;rtag==<span class="number">0</span>) p=p-&gt;rchild;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">//在中序线索二叉树中找到结点P的前继结点 </span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>) <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ThreadNode *p=Lastnode(T);p!=<span class="literal">NULL</span>;p=Prenode(p))&#123;</span><br><span class="line">		visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/iloveflag/images/master/1919921201051.png" alt=""></p>
<h2 id="5-12-树的存储结构"><a href="#5-12-树的存储结构" class="headerlink" title="5.12 树的存储结构"></a>5.12 树的存储结构</h2><h3 id="双亲表示法-顺序存储"><a href="#双亲表示法-顺序存储" class="headerlink" title="双亲表示法(顺序存储)"></a>双亲表示法(顺序存储)</h3><p>每个结点中保存指向双亲的”指针”<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	PTNode nodes[Max_TREE_SIZE];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>优点:查指定结点的双亲很方便<br>缺点:空数据导致遍历更慢，查指定结点的孩子只能从头遍历</p>
<h3 id="孩子表示法-顺序＋链式存储"><a href="#孩子表示法-顺序＋链式存储" class="headerlink" title="孩子表示法(顺序＋链式存储)"></a>孩子表示法(顺序＋链式存储)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> child;  <span class="comment">//孩子结点在数组中位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ELemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">	<span class="type">int</span> n,r; <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法-链式存储"><a href="#孩子兄弟表示法-链式存储" class="headerlink" title="孩子兄弟表示法(链式存储)"></a>孩子兄弟表示法(链式存储)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的存储--孩子兄弟表示法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree; </span><br></pre></td></tr></table></figure>
<h4 id="树和二叉树的转化"><a href="#树和二叉树的转化" class="headerlink" title="树和二叉树的转化"></a>树和二叉树的转化</h4><p>树转二叉树<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/652348219477.png" alt=""><br>二叉树转树<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/267049207344.png" alt=""><br><mark>森林和二叉树的转化</mark><br>森林转二叉树<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/5036050227510.png" alt=""><br>二叉树转森林<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/4339851220179.png" alt=""></p>
<h2 id="5-13-树和森林的遍历"><a href="#5-13-树和森林的遍历" class="headerlink" title="5.13 树和森林的遍历"></a>5.13 树和森林的遍历</h2><h3 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h3><p>若树非空，先访问根结点，再依次对每根子树进行先根遍历。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		visit(R);</span><br><span class="line">		<span class="keyword">while</span>(R还有下一个子树T)&#123;</span><br><span class="line">			PreOrder(T);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>利用孩子兄弟表示法转化为二叉树<br><mark>树的先根遍历序列与这棵树相应二叉树的先序序列相同</mark></p>
<h3 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h3><p>若树非空，先依次对每颗子树进行后根遍历，最后再访问根结点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(R还有下一个子树T)&#123;</span><br><span class="line">			PostOrder(T);</span><br><span class="line">		&#125;</span><br><span class="line">	   visit(R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br><mark>树的后根遍历序列与这棵树相应二叉树的中序序列相同</mark></p>
<h3 id="树的层次遍历-用队列实现"><a href="#树的层次遍历-用队列实现" class="headerlink" title="树的层次遍历(用队列实现)"></a>树的层次遍历(用队列实现)</h3><p>1.若树非空，则根节点入队<br>2.若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队<br>3重复2直至队列为空</p>
<p>层次遍历—广度优先遍历<br>先根和后根—层次优先遍历</p>
<h3 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h3><p>效果等同于依次对各个树进行<mark>先根遍历</mark><br>效果等同与依次对二叉树的<mark>先序遍历</mark></p>
<h3 id="森林的中序遍历"><a href="#森林的中序遍历" class="headerlink" title="森林的中序遍历"></a>森林的中序遍历</h3><p>效果等同于依次对各个树进行<mark>后根遍历</mark><br>效果等同于依次对二叉树的<mark>中序遍历</mark><br>紫页p139<br>| 树    | 森林    |二叉树     |<br>| :-: | :-: | :-: |<br>|  先根遍历   |  先序遍历   | 先序遍历    |<br>|   后根遍历  | 中序遍历    | 中序遍历    |</p>
<h2 id="5-14-二叉排序树"><a href="#5-14-二叉排序树" class="headerlink" title="5.14 二叉排序树"></a>5.14 二叉排序树</h2><p>二叉排序树，又称二叉查找树(BST)<br>左子树上所有结点的关键字均小于根节点的关键字<br>右子树上所有结点的关键字均小于根节点的关键字<br>左子树和右子树又各是一棵二叉排序树<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">		<span class="keyword">if</span>(key&lt;T-&gt;key) T=T-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span> T=T-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>递归实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(key==T-&gt;key)&#123;</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line">		<span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BSTSrearch(T-&gt;rchild,key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>worst O(h)<br>best O(1)</p>
<h3 id="二叉树的插入"><a href="#二叉树的插入" class="headerlink" title="二叉树的插入"></a>二叉树的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		T=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">		T-&gt;key=k;</span><br><span class="line">		T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)&#123;</span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worst O(h)</p>
<h3 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BSTree &amp;T,<span class="type">int</span> str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	T=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">		BST_Insert(T,str[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><p>先搜索找到目标结点<br>1.若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质<br>2.若结点z只有一棵左子树和右子树，则让z的子树成为z父节点的子树，替代z的位置<br>3.若结点z有左，右两棵子树，则令z的直接后继(或直接前驱)替代z，然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况<br>左子树结点值&lt;根结点值&lt;右子树结点值<br>EXP：查找右子树中最小的，即进行中序遍历，可以得到一个递增的有序序列</p>
<p>z的后继:z的右子树中最左下结点(该节点一定没有左子树)<br>z的前驱:z的左子树中最右下结点(该节点一定没有右子树)<br>参照线索二叉树</p>
<h3 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h3><p>查找长度—在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度<br>计算题:查找成功/失败的平均查找长度ASL(Average Search Length)</p>
<h2 id="5-15-平衡二叉树-选择题"><a href="#5-15-平衡二叉树-选择题" class="headerlink" title="5.15 平衡二叉树(选择题)"></a>5.15 平衡二叉树(选择题)</h2><p>AVL树-树上任一结点的左子树和右子树的高度之差不超过1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="type">int</span> balance;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree; </span><br></pre></td></tr></table></figure><br>从插入点往回找到第一个不平衡结点，调整以该结点为根的子树</p>
<h3 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h3><p>在A的左孩子的左子树中插入导致不平衡<br>1）LL平衡旋转（右单旋转）。由于在结点A的左孩子（L）的左子树（L）上插入了新结点，A的平衡因子<br>由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的左孩子B向右上旋转代替A成<br>为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/2318544229484.png" alt=""></p>
<h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/4645544217351.png" alt=""><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/3793846237517.png" alt=""></p>
<h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><p>先左旋后右旋<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/1869848230186.png" alt=""></p>
<h3 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h3><p>先右旋后左旋<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/3194549226741.png" alt=""><br>可以证明含有n个结点的平衡二叉树的最大深度为o（log2n)，平衡二叉树的平均查找长度为o（log2n）</p>
<h2 id="5-16-哈夫曼树"><a href="#5-16-哈夫曼树" class="headerlink" title="5.16 哈夫曼树"></a>5.16 哈夫曼树</h2><p>结点的权:某种现实含义的数值(如:表示结点的重要性等)<br>结点的带权路径长度:从树的根到该结点的路径长度(经过的边数)与该结点上权值的乘积<br>树的带权路径长度:树中所有<mark>叶节点</mark>的带权路径长度之和 WPL<br>在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树</p>
<h3 id="哈夫曼的构造"><a href="#哈夫曼的构造" class="headerlink" title="哈夫曼的构造"></a>哈夫曼的构造</h3><p>很简单，最小的权值结点先相加，依次类推<br>1.每个初始结点最终都成为叶结点，且权值最小的结点到根结点的路径长度最大<br>2.哈夫曼树的结点总数为2n-1<br>3.哈夫曼树中不存在度为1的结点<br>4.哈夫曼树并不唯一。但WPL必然相同为最优</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>可变长度编码—允许对不同字符用不等长的二进制位表示<br>若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码<br>前缀编码无歧义<br>有哈夫曼树得到哈夫曼编码—字符集中的每个字符作为一个<mark>叶子结点</mark>，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树<br>考点:将字符频次作为字符结点权值，构造哈夫曼树，即可得哈夫曼编码，可用于数据压缩</p>
<h1 id="6-图"><a href="#6-图" class="headerlink" title="6.图"></a>6.图</h1><h2 id="6-2-邻接矩阵法"><a href="#6-2-邻接矩阵法" class="headerlink" title="6.2 邻接矩阵法"></a>6.2 邻接矩阵法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> Vex[MaxVertexNum];</span><br><span class="line">	<span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];</span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph; </span><br></pre></td></tr></table></figure>
<p>无向图:<br>第i个结点的度=第i行(或第i列)的非零元素个数<br>有向图:<br>第i个结点的出度=第i行的非零元素个数<br>第i个结点的入度=第i列的非零元素个数<br>第i个结点的度=第i行，第i列的非零元素个数之和</p>
<p>邻接矩阵法存储带权图:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100     <span class="comment">//顶点数目的最大值 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 最大的int值  <span class="comment">//宏定义常量&quot;无穷&quot; </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;    <span class="comment">//顶点的数据类型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;   <span class="comment">//带权图中边上权值的数据类型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VertexType Vex[MaxVertexNum]; <span class="comment">//顶点 </span></span><br><span class="line">	EdgeType Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//边的权 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum; <span class="comment">//图的当前顶点数和弧数 </span></span><br><span class="line">&#125;MGraph; </span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/4995447151059.png" alt=""><br>不适合存储稀疏图</p>
<h2 id="6-3-邻接表法"><a href="#6-3-邻接表法" class="headerlink" title="6.3 邻接表法"></a>6.3 邻接表法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用邻接表存储的图 </span></span><br><span class="line"><span class="comment">//用邻接表存储的图 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	AdjList vertices;</span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;边/弧&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;   <span class="comment">//边/弧指向哪个结点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条弧的指针 </span></span><br><span class="line">	<span class="comment">//InfoType info;       //边权值 </span></span><br><span class="line">&#125;ArcNode; </span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;顶点&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">	VertexType data; <span class="comment">//顶点信息 </span></span><br><span class="line">	ArvNode *first; <span class="comment">//第一条边/弧 </span></span><br><span class="line">&#125;VNode,Adjist[MaxVertexNum]; </span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/iloveflag/images/master/1781456169485.png" alt=""><br>比较:<a href="#孩子表示法(顺序＋链式存储">孩子表示法(顺序＋链式存储)</a>)<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/5086101167352.png" alt=""></p>
<h2 id="6-4-十字链表-邻接多重表"><a href="#6-4-十字链表-邻接多重表" class="headerlink" title="6.4 十字链表,邻接多重表"></a>6.4 十字链表,邻接多重表</h2><h2 id="6-5-图的基本操作"><a href="#6-5-图的基本操作" class="headerlink" title="6.5  图的基本操作"></a>6.5  图的基本操作</h2><h2 id="6-6-图的广度优先遍历-BFS"><a href="#6-6-图的广度优先遍历-BFS" class="headerlink" title="6.6 图的广度优先遍历(BFS)"></a>6.6 图的广度优先遍历(BFS)</h2><p>1.找到与一个顶点相邻的所有顶点<br>2.标记哪些顶点被访问过<br>3.需要一个辅助队列<br>FirstNeighbor(G,x)<br>NextNeighbor(G,x,y)</p>
<p>对于无向图,调用BFS函数的次数=连通分量数<br>邻接矩阵存储的图:`时间复杂度=O(|V|^2)<br>邻接表存储的图:时间复杂度=O(|V|+|E|)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM]; <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123; <span class="comment">//对图G进行广度优先遍历 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexum;++i)&#123; </span><br><span class="line">		visited[i]=FALSE;  <span class="comment">//访问标记数组初始化 </span></span><br><span class="line">	&#125;</span><br><span class="line">	InitQueue(Q); <span class="comment">//初始化辅助队列Q </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;   <span class="comment">//从0号顶点开始遍历 </span></span><br><span class="line">		<span class="keyword">if</span>(!visited[i])&#123;  <span class="comment">//对每个连通分量调用一次BFS </span></span><br><span class="line">			BFS(G,i); <span class="comment">//vi未访问过,从vi开始BFS </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	visit(v);    <span class="comment">//访问初始顶点v </span></span><br><span class="line">	visited[v]=TRUE; <span class="comment">//对v做已访问标记 </span></span><br><span class="line">	Enqueue(Q,v);   <span class="comment">//顶点v入队列Q </span></span><br><span class="line">	<span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">		DeQueue(Q,v);  <span class="comment">//顶点v出队列 </span></span><br><span class="line">		<span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))&#123;</span><br><span class="line">			<span class="comment">//检测v所有邻接点 </span></span><br><span class="line">			<span class="keyword">if</span>(!visited[w])&#123;  <span class="comment">//w为v的尚未访问的邻接顶点 </span></span><br><span class="line">				visit(w);  <span class="comment">//访问顶点w </span></span><br><span class="line">				visited[w]=TRUE; <span class="comment">//对w做已访问标记 </span></span><br><span class="line">				EnQueue(Q,w); <span class="comment">//顶点w入队列 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>广度优先生成树由广度优先遍历过程确定.由于邻接表的表示方式不唯一,因此基于邻接表的广度优先生成树也不唯一.<br>对非连通图的广度优先遍历,可得到广度优先生成森林</p>
<h2 id="6-7-深度优先遍历-DFS"><a href="#6-7-深度优先遍历-DFS" class="headerlink" title="6.7 深度优先遍历(DFS)"></a>6.7 深度优先遍历(DFS)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM]; <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123; <span class="comment">//对图G进行深度优先遍历 </span></span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexum;++v)&#123; </span><br><span class="line">		visited[v]=FALSE;  <span class="comment">//访问标记数组初始化 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">			DFS(G,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	visit(v);</span><br><span class="line">	visited[v]=TRUE;</span><br><span class="line">	<span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighor(G,v,w))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">			DFS(G,w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>邻接矩阵存储的图:`时间复杂度=O(|V|^2)<br>邻接表存储的图:时间复杂度=O(|V|+|E|)</p>
<h2 id="6-8-最小生成树"><a href="#6-8-最小生成树" class="headerlink" title="6.8 最小生成树"></a>6.8 最小生成树</h2><h2 id="6-9-11-图算法"><a href="#6-9-11-图算法" class="headerlink" title="6.9-11 图算法"></a>6.9-11 图算法</h2><p>Floyd<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备工作,根据图的信息初始化矩阵A和path </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;   <span class="comment">//考虑以Vk为中转点 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   <span class="comment">//遍历整个矩阵,i为行号,j为列号 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])&#123;   <span class="comment">//以Vk为中转点的路径更短 </span></span><br><span class="line">				A[i][j]=A[i][k]+A[k][j];   <span class="comment">//更新最短路径长度 </span></span><br><span class="line">				path[i][j]=k;   <span class="comment">//中转点 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/5979441161070.png" alt=""></p>
<h1 id="7-查找"><a href="#7-查找" class="headerlink" title="7.查找"></a>7.查找</h1><h2 id="7-1-查找的基本概念"><a href="#7-1-查找的基本概念" class="headerlink" title="7.1 查找的基本概念"></a>7.1 查找的基本概念</h2><p>仅关注查找速度-静态查找表<br>除了查找速度,也要关注插/删操作是否方便实现</p>
<h2 id="7-2-顺序查找"><a href="#7-2-顺序查找" class="headerlink" title="7.2 顺序查找"></a>7.2 顺序查找</h2><h2 id="7-3-折半查找"><a href="#7-3-折半查找" class="headerlink" title="7.3 折半查找"></a>7.3 折半查找</h2><p>仅适用于有序的顺序表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="type">int</span> TableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SSTable L,ElemType key)</span>&#123;</span><br><span class="line">	<span class="type">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">		mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(L.elem[mid]==key)&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)&#123;</span><br><span class="line">			high=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			low=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>右子树结点数-左子树结点数=0或1<br>折半查找的判定树一定是平衡二叉树<br>折半查找的判定数中,只有最下面一层是不满的<br>因此,元素个数为n时树高h=[log2(n+1)]<br>满足二叉树的定义,失败结点为n+1</p>
<h2 id="7-4-分块查找"><a href="#7-4-分块查找" class="headerlink" title="7.4 分块查找"></a>7.4 分块查找</h2><p>分块查找,又称索引顺序查找,算法过程如下:<br>1.在索引表中确定待查记录所属的分块(可顺序.可折半)<br>2.在块内顺序查找<br>若索引表中不包含目标关键字,则<mark>折半查找</mark>索引表最终停在low&gt;high,要在<mark>low所指分块中查找</mark><br>原因:最终low左边一定小于目标关键字,high右边一定大于目标关键字.而分块存储的索引表中保存的是各个分块的最大关键字<br>顺序查找索引表 ASL=(b+1)/2+(s+1)/2 当s=√n +1</p>
<h2 id="7-5-7-B树"><a href="#7-5-7-B树" class="headerlink" title="7.5-7 B树"></a>7.5-7 B树</h2><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/2758507141145.png" alt=""><br><img src="https://raw.githubusercontent.com/iloveflag/images/master/1188517169571.png" alt=""></p>
<h2 id="7-8-9-散列"><a href="#7-8-9-散列" class="headerlink" title="7.8-9 散列"></a>7.8-9 散列</h2><p>1.线性探测法:发生冲突时,每次往后探测相邻的下一个单元是否为空<br>注意:采用”开放定制法”时,删除结点不能简单地将被删除结点的空间置为空,否则将截断在它之后填入散列表的同义词结点的查找路径,可以做一个”删除标记”,进行逻辑删除<br>2.平方探测法.d=….,k^2,-k^2<br>散列表长度m必须是一个可以表示成4j+3的素数,才能探测到所有位置<br>3.伪随机数序列法</p>
<h1 id="8-排列"><a href="#8-排列" class="headerlink" title="8.排列"></a>8.排列</h1><h2 id="8-1-排序的基本概念"><a href="#8-1-排序的基本概念" class="headerlink" title="8.1 排序的基本概念"></a>8.1 排序的基本概念</h2><p>排序算法的稳定性<br>关键字相同的元素在排序之后相对位置不变<br>内部排序:数据都在内存中<br>外部排序:数据太多,无法全部放入内存</p>
<h2 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h2><p>每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中,直到全部记录插入完成.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span>  i,j,temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">			temp=A[i];</span><br><span class="line">			<span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;<span class="number">0</span>&amp;&amp;A[j]&gt;temp;--j)&#123;</span><br><span class="line">				A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">			&#125;</span><br><span class="line">			A[j+<span class="number">1</span>]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>哨兵:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span>  i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">			A[<span class="number">0</span>]=A[i];</span><br><span class="line">			<span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];--j)&#123;</span><br><span class="line">				A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">			&#125;</span><br><span class="line">			A[j+<span class="number">1</span>]=A[<span class="number">0</span>]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>优化-折半插入排序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,low.high,mid;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		A[<span class="number">0</span>]=A[i];</span><br><span class="line">		low=<span class="number">1</span>;high=i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">			mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>]) high=mid<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span> low=mid+<span class="number">1</span>; <span class="comment">//查找右半子表 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)&#123;</span><br><span class="line">			A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">		&#125;</span><br><span class="line">		A[high+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>当low&gt;high时折半查找停止,应将[low,i-1]内的元素全部右移,并将A[0]复制到low所指位置<br>当A[mid]==A[0]时,为了保证算法的稳定性,应继续在mid所指位置右边寻找插入位置<br>-&gt;对链表进行插入排序<br>avg 0(n^2)</p>
<h2 id="8-3-希尔排序"><a href="#8-3-希尔排序" class="headerlink" title="8.3 希尔排序"></a>8.3 希尔排序</h2><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/5252914151146.png" alt=""><br>每次将增量缩小一半<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span> d,i,j;</span><br><span class="line">	<span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i]&lt;A[i-d])&#123;</span><br><span class="line">				A[<span class="number">0</span>]=A[i];</span><br><span class="line">				<span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)&#123;</span><br><span class="line">					A[j+d]=A[j];</span><br><span class="line">				&#125;</span><br><span class="line">				A[j+d]=A[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>仅适用于顺序表</p>
<h2 id="8-4-冒泡排序"><a href="#8-4-冒泡排序" class="headerlink" title="8.4 冒泡排序"></a>8.4 冒泡排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a;<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;</span><br><span class="line">				swap(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">				flag=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="literal">false</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-5-快速排序-代码重点"><a href="#8-5-快速排序-代码重点" class="headerlink" title="8.5 快速排序(代码重点)"></a>8.5 快速排序(代码重点)</h2><p>用第一个元素把待排序序列划分为两个部分.左边更小,右边更大,该元素的最终位置已确定<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[],itn low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)&#123;  <span class="comment">//递归跳出的条件 </span></span><br><span class="line">		<span class="type">int</span> pivotpos=Partition(A,low,high); <span class="comment">//划分 </span></span><br><span class="line">		QuickSort(A,low,pivotpos<span class="number">-1</span>);  <span class="comment">//划分左子表 </span></span><br><span class="line">		QuickSort(A,pivotpos+<span class="number">1</span>,high);  <span class="comment">//划分右子表 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">	<span class="type">int</span> pivot=A[low];  <span class="comment">//第一个元素作为枢轴 </span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;high)&#123;  <span class="comment">//用low,high搜索枢轴的最终位置 </span></span><br><span class="line">		<span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot) --high;</span><br><span class="line">		A[low]=A[high]; <span class="comment">//比枢轴小的元素移动到左端 </span></span><br><span class="line">		<span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot) ++low;</span><br><span class="line">		A[high]=A[low];  <span class="comment">//比枢轴大的元素移动到右端 </span></span><br><span class="line">	&#125;</span><br><span class="line">	A[low]=pivot;  <span class="comment">//枢轴元素存放到最终位置 </span></span><br><span class="line">	<span class="keyword">return</span> low; <span class="comment">//返回存放枢轴位置的最终位置 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>时间复杂度=O(n*递归层数)<br>空间复杂度=O(递归层数)<br>把n个元素组织成二叉树,二叉树的层数就是递归调用的层数<br>最小高度=[log2 n]+1<br>最大高度=n</p>
<p>若每⼀次选中的“枢轴”将待排序序列<br>划分为很不均匀的两个部分，则会导<br>致递归深度增加，算法效率变低</p>
<p>若初始序列有序或逆序，则快速排序<br>的性能最差（因为每次选择的都是最<br>靠边的元素）</p>
<p>若每⼀次选中的“枢轴”将待排序序列<br>划分为均匀的两个部分，则递归深度<br>最⼩，算法效率最⾼</p>
<p>快速排序算法优化思路：尽量选择可以把<br>数据中分的枢轴元素。<br>eg：①选头、中、尾三个位置的元素，取<br>中间值作为枢轴元素；②随机选⼀个元素<br>作为枢轴元素</p>
<p>算法稳定性:不稳定</p>
<h2 id="8-6-选择排序"><a href="#8-6-选择排序" class="headerlink" title="8.6 选择排序"></a>8.6 选择排序</h2><p>每一趟在待排序元素中选取关键字最小的元素加入有序子序列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> min=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j]&lt;A[min]) min=j;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(min!=i) swap(A[i],A[min]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不稳定<br>既可以用于顺序表,也可以用于链表</p>
<h2 id="8-7-堆排序"><a href="#8-7-堆排序" class="headerlink" title="8.7 堆排序"></a>8.7 堆排序</h2><p>大根堆:L(i)&gt;=L(2i)且L(i)&gt;=L(2i+1)  在完全二叉树中根&gt;=左,右<br>小根堆:L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1) 在完全二叉树中根&lt;=左,右</p>
<h3 id="建立大根堆"><a href="#建立大根堆" class="headerlink" title="建立大根堆"></a>建立大根堆</h3><p>把所有非终端结点都检查一遍,是否满足大根堆的要求,如果不满足,则进行调整</p>
<p>检查当前结点是否满足根&gt;=左,右  若不满足,将当前结点与更大的一个孩子互换</p>
<p>若元素互换破坏了下一级的堆,则采用相同的方法继续往下调整(小元素不断下坠)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&lt;<span class="number">0</span>;i--)&#123; <span class="comment">//从后往前调整所有非终端结点 </span></span><br><span class="line">		HeadAdjust(A,i,len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	A[<span class="number">0</span>]=A[k]; <span class="comment">//A[0]暂存子树的根结点 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123; <span class="comment">//沿key较大的子节点向下筛选 </span></span><br><span class="line">		<span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">			i++;     <span class="comment">//取key较大的子结点的下标 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i]) <span class="keyword">break</span>; <span class="comment">//筛选结束 </span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			A[k]=A[i]; <span class="comment">//将A[i]调整到双亲结点上 </span></span><br><span class="line">			k=i;  <span class="comment">//修改k值,以便继续向下筛选 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	A[k]=A[<span class="number">0</span>]; <span class="comment">//被筛选结点的值放入最终位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于大根堆进行排序"><a href="#基于大根堆进行排序" class="headerlink" title="基于大根堆进行排序"></a>基于大根堆进行排序</h3><p>堆排序:每一趟将堆顶元素加入有序序列<br>并将待排序元素序列再次调整为大根堆<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	BuildMaxHeap(A,len);  <span class="comment">//初始建堆 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;  <span class="comment">//n-1趟的交换和建堆过程 </span></span><br><span class="line">		swap(A[i],A[<span class="number">1</span>]);  <span class="comment">//堆顶元素和堆低元素交换 </span></span><br><span class="line">		HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);  <span class="comment">//把剩余的待排序元素整理成堆 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br><mark>建堆的过程,关键字对比次数不超过4n,建堆时间复杂度=O(n)</mark><br>堆排序的时间复杂度=O(n)+O(nlog2n)=O(nlog2n)<br>空间复杂度O(1)</p>
<p>堆排列是不稳定的</p>
<h2 id="8-8-堆的插入删除"><a href="#8-8-堆的插入删除" class="headerlink" title="8.8 堆的插入删除"></a>8.8 堆的插入删除</h2><p>对于小根堆,新元素放到表尾,与父节点对比.若新元素比父节点更小,则二者互换.新元素就这样一路上升,直到无法继续上升为止<br>被删除的元素用堆底元素替代,然后让该元素不断”下坠”,直到无法下坠为止<br>关键字对比次数:<br>每次”上升”调整只需对比关键字1次<br>每次”下坠”调整可能需要对比关键字2次,也可能只需要对比1次</p>
<h2 id="8-9-归并排序"><a href="#8-9-归并排序" class="headerlink" title="8.9 归并排序"></a>8.9 归并排序</h2><p>Merge<br>归并:把两个或多个已经有序的序列合并成一个<br>只剩一个子表未合并时,可以将该表中剩余元素全部加到总表<br>4路归并则每选出一个小元素注需比对关键字3次<br>结论:m路归并,每选出一个元素需要对比关键字m-1次<br>在内部排序中一般采用2路归并<br>核心操作:把数组内的两个有序序列归并为一个<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k;</span><br><span class="line">	<span class="keyword">for</span>(k=low;k&lt;=high;k++)&#123;</span><br><span class="line">		B[k]=A[k];   <span class="comment">//将A中所有元素复制到B中 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(B[i]&lt;=B[j])&#123;</span><br><span class="line">			A[k]=B[i++];   <span class="comment">//将较小值复制到A中 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			A[k]=B[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">		<span class="type">int</span> mid=(low+high)/<span class="number">2</span>;  <span class="comment">//从中间划分 </span></span><br><span class="line">		MergeSort(A,low,mid);  <span class="comment">//对左半部分归并 </span></span><br><span class="line">		MergeSort(A,mid+<span class="number">1</span>,high); <span class="comment">//对右半部分归并 </span></span><br><span class="line">		Merge(A,low,mid,high); <span class="comment">//归并 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结论:n个元素进行2路归并排序,归并趟数=[log2 n]<br>时间复杂度O(nlog2 n)<br>空间复杂度O(n),来自于辅助数组B<br>稳定的性能</p>
<h2 id="8-10-基数排序"><a href="#8-10-基数排序" class="headerlink" title="8.10 基数排序"></a>8.10 基数排序</h2><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/5240113141147.png" alt=""><br>基数排序不是基于”比较”的排序算法<br>空间复杂度O(r)<br>时间复杂度O(d(n+r))<br>基数排序是稳定的<br>基数排序擅长解决的问题:<br>1.数据元素的关键字可以方便地拆分为d组,且d较小<br>2.每组关键字的取值范围不大,即r较小<br>3.数据元素个数n较大</p>
<h2 id="8-11-外部排序"><a href="#8-11-外部排序" class="headerlink" title="8.11 外部排序"></a>8.11 外部排序</h2><p>磁盘的读/写以”块”为单位,数据读入内存后才能被修改,修改完了还要写回磁盘<br>外部排序:数据元素太多,无法一次全部读入内存进行排序<br>使用”归并排序”的方法,最少只需在内存中分配3块大小的缓冲区即可对任意一个文件进行排序<br>“归并排序”要求各个子序列有序,每次读入两个块的内容,进行内部排序后写回磁盘<br><img src="https://raw.githubusercontent.com/iloveflag/images/master/5669809169573.gif" alt="动画"><br>外部排序时间开销=读写外存的时间+内部排序所需的时间+内部归并所需时间<br>重要结论:采用多路归并可以减少归并趟数,从而减少磁盘I/O(读写)次数<br>对 r 个初始归并段，做k路归并，则归并树可⽤ k 叉树表示<br>若树⾼为h，则归并趟数 = h-1 = ⌈logk r⌉</p>
<p>多路归并带来的负面影响:<br>1.k路归并时,需要开辟k个输入缓冲区,内存开销增加<br>2.每挑选一个关键字需要对比关键字(k-1)次,内部归并所需时间增加</p>
<p>结论：若能增加初始归并段的⻓度，则可减少初始归并段数量 r</p>
<h2 id="8-12-败者树—选出最小元素log2-k次"><a href="#8-12-败者树—选出最小元素log2-k次" class="headerlink" title="8.12 败者树—选出最小元素log2 k次"></a>8.12 败者树—选出最小元素log2 k次</h2><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/2771243157440.png" alt=""></p>
<h2 id="8-13-置换—选择排序-r↓"><a href="#8-13-置换—选择排序-r↓" class="headerlink" title="8.13 置换—选择排序 r↓"></a>8.13 置换—选择排序 r↓</h2><p><img src="https://raw.githubusercontent.com/iloveflag/images/master/406053177606.png" alt=""></p>
<h2 id="8-14-最佳归并树"><a href="#8-14-最佳归并树" class="headerlink" title="8.14 最佳归并树"></a>8.14 最佳归并树</h2><p>归并过程中的磁盘I/O次数=归并树的WPL*2<br><a href="#哈夫曼的构造">#哈夫曼的构造</a><br>-&gt;多路归并的最佳归并树<br>注意：对于k叉归并，若初始归并段的数量⽆法构成严格的 k 叉归并树，<br>则需要补充⼏个⻓度为 0 的“虚段”，再进⾏ k 叉哈夫曼树的构造。<br>①若（初始归并段数量 -1）% （k-1）= 0，说明刚好可以构成严格k叉树，此时不需要添加虚段<br>②若（初始归并段数量 -1）% （k-1）= u ≠ 0，则需要补充 (k-1) - u 个虚段</p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://iloveflag.github.io">iloveflag</a>
            <p>原文链接：<a href="https://iloveflag.github.io/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://iloveflag.github.io/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</a>
            <p>发表日期：<a href="https://iloveflag.github.io/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">November 6th 2021, 5:00:00 pm</a>
            <p>更新日期：<a href="https://iloveflag.github.io/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">February 14th 2025, 10:45:19 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2022/12/12/QVD-2022-46174-thinkphp%E5%A4%9A%E8%AF%AD%E8%A8%80RCE/" title= "QVD-2022-46174-thinkphp多语言RCE">
                    <div class="nextTitle">QVD-2022-46174-thinkphp多语言RCE</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/09/23/RSA%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/" title= "RSA与费马小定理">
                    <div class="prevTitle">RSA与费马小定理</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <div id="comment-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
            clientID: '54c5c6bc527e05e0c678',
            clientSecret: '9d67009d7099559da82f61c73abafce18d09d6d9',
            id: '1636189200000',
            repo: 'iloveflag.github.io',
            owner: 'iloveflag',
            admin: "iloveflag",
            createIssueManually: true,
            distractionFreeMode: false
        })
        gitalk.render('comment-container')
    </script>
    
    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
    
        
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:iloveflag@outlook.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/iloveflag" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DS"><span class="toc-number">1.</span> <span class="toc-text">DS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">2.线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.2 顺序表的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">顺序表的静态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">2.1.2.</span> <span class="toc-text">顺序表的动态分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.</span> <span class="toc-text">2.3 顺序表的插入删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.2.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">2.2.3.</span> <span class="toc-text">按值查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.</span> <span class="toc-text">2.5 单链表的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">常规定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A6%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">书本中的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">不带头节点的单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">带头节点的单链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.</span> <span class="toc-text">2.6 单链表的插入删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5%EF%BC%88%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">按位序插入（带头结点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5%EF%BC%88%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">按位序插入（不带头结点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E7%9A%84%E5%90%8E%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.3.</span> <span class="toc-text">指定结点的后插操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E7%9A%84%E5%89%8D%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.4.</span> <span class="toc-text">指定结点的前插操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BA%8F%E5%88%A0%E9%99%A4%EF%BC%88%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89"><span class="toc-number">2.4.5.</span> <span class="toc-text">按位序删除（带头结点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.6.</span> <span class="toc-text">指定结点的删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">2.5.</span> <span class="toc-text">2.7 单链表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%9F%A5%E6%89%BE"><span class="toc-number">2.5.1.</span> <span class="toc-text">按位查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">按值查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.5.3.</span> <span class="toc-text">求表的长度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">2.8 单链表的建立</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">2.5.4.</span> <span class="toc-text">尾插法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="toc-number">2.5.5.</span> <span class="toc-text">头插法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">2.9 双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.6.1.</span> <span class="toc-text">定义与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">2.6.2.</span> <span class="toc-text">双链表的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">2.6.3.</span> <span class="toc-text">双链表的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">2.6.4.</span> <span class="toc-text">双链表的销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.5.</span> <span class="toc-text">双链表的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E5%BE%AA%E7%8E%AF%E5%88%97%E8%A1%A8"><span class="toc-number">2.7.</span> <span class="toc-text">2.10 循环列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text">循环单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.7.2.</span> <span class="toc-text">循环双链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">2.7.3.</span> <span class="toc-text">循环双链表的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">2.7.4.</span> <span class="toc-text">循环双链表的删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">2.8.</span> <span class="toc-text">2.11 静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.8.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">2.8.2.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%BD%8D%E5%BA%8F%E4%B8%BAi%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">2.8.3.</span> <span class="toc-text">插入位序为i的结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">2.8.4.</span> <span class="toc-text">删除某个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.8.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.9.</span> <span class="toc-text">2.12 顺序表和链表的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">3.栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 栈的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 栈的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.1.</span> <span class="toc-text">初始化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.2.</span> <span class="toc-text">进栈操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.3.</span> <span class="toc-text">出栈操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.4.</span> <span class="toc-text">读栈顶元素操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.2.5.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">3.2.6.</span> <span class="toc-text">共享栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 栈的链式存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%88%97%E9%98%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 列队的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%88%97%E9%98%9F%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 列队的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.1.</span> <span class="toc-text">队列的顺序实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%98%9F"><span class="toc-number">3.5.2.</span> <span class="toc-text">入队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E9%98%9F"><span class="toc-number">3.5.3.</span> <span class="toc-text">出队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96"><span class="toc-number">3.5.4.</span> <span class="toc-text">读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.5.</span> <span class="toc-text">判断队列状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E4%B8%80"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E4%BA%8C"><span class="toc-number">3.5.5.2.</span> <span class="toc-text">法二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E4%B8%89"><span class="toc-number">3.5.5.3.</span> <span class="toc-text">法三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">3.5.5.4.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%88%97%E9%98%9F%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 列队的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">3.6.1.</span> <span class="toc-text">初始化(带头结点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">3.6.2.</span> <span class="toc-text">初始化(不带头结点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%98%9F-%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">3.6.3.</span> <span class="toc-text">入队(带头结点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%98%9F-%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">3.6.4.</span> <span class="toc-text">入队(不带头结点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E9%98%9F-%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">3.6.5.</span> <span class="toc-text">出队(带头结点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E9%98%9F-%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">3.6.6.</span> <span class="toc-text">出队(不带头结点)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 栈在括号匹配中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%90%8E%E7%BC%80%E4%B8%BA%E9%87%8D%E7%82%B9"><span class="toc-number">3.9.</span> <span class="toc-text">3.9 栈在表达式求值中的应用（上）(后缀为重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%89%8B%E7%AE%97"><span class="toc-number">3.9.1.</span> <span class="toc-text">中缀表达式转后缀表达式(手算):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97-%E6%89%8B%E7%AE%97"><span class="toc-number">3.9.2.</span> <span class="toc-text">后缀表达式的计算(手算)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97-%E6%9C%BA%E7%AE%97"><span class="toc-number">3.9.3.</span> <span class="toc-text">后缀表达式的计算(机算)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%89%8B%E7%AE%97"><span class="toc-number">3.9.4.</span> <span class="toc-text">中缀表达式转前缀表达式(手算)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">3.9.5.</span> <span class="toc-text">前缀表达式的计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-number">3.10.</span> <span class="toc-text">3.10 栈在表达式求值中的应用（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%9C%BA%E7%AE%97"><span class="toc-number">3.10.1.</span> <span class="toc-text">中缀表达式转后缀表达式(机算)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.10.2.</span> <span class="toc-text">中缀表达式的计算(用栈实现)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.11.</span> <span class="toc-text">3.11 栈在递归中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.12.</span> <span class="toc-text">3.12 队列的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">3.13.</span> <span class="toc-text">3.13 特殊矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.13.1.</span> <span class="toc-text">一维数组的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.13.2.</span> <span class="toc-text">二维数组的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">3.13.3.</span> <span class="toc-text">普通矩阵的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">3.13.4.</span> <span class="toc-text">对称矩阵的压缩存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">3.13.5.</span> <span class="toc-text">三角矩阵的压缩存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">3.13.6.</span> <span class="toc-text">三对角矩阵的压缩存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">3.13.7.</span> <span class="toc-text">稀疏矩阵的压缩存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">4.串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 串的定义和基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 串的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">串的顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">串的链式存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%AD%90%E4%B8%B2"><span class="toc-number">4.2.3.</span> <span class="toc-text">求子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text">比较大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.5.</span> <span class="toc-text">定位操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 朴素模式匹配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-KMP%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 KMP算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%B1%82next%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 求next数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">5.二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">5.5 二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.</span> <span class="toc-text">5.6 二叉树的先中后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.</span> <span class="toc-text">5.7 二叉树的层次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.4.</span> <span class="toc-text">5.8 由遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.</span> <span class="toc-text">5.9 线索二叉树的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">5.6.</span> <span class="toc-text">5.10 二叉树的线索化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">5.6.1.</span> <span class="toc-text">中序线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">5.6.2.</span> <span class="toc-text">先序线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">5.6.3.</span> <span class="toc-text">后序线索化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-11-%E5%9C%A8%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7"><span class="toc-number">5.7.</span> <span class="toc-text">5.11 在线索二叉树中找前驱后继</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-number">5.7.1.</span> <span class="toc-text">中序线索二叉树中找中序后继</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E4%B8%AD%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-number">5.7.2.</span> <span class="toc-text">中序线索二叉树中找中序前驱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-12-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.8.</span> <span class="toc-text">5.12 树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.8.1.</span> <span class="toc-text">双亲表示法(顺序存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F%EF%BC%8B%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.8.2.</span> <span class="toc-text">孩子表示法(顺序＋链式存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.8.3.</span> <span class="toc-text">孩子兄弟表示法(链式存储)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-number">5.8.3.1.</span> <span class="toc-text">树和二叉树的转化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-13-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.9.</span> <span class="toc-text">5.13 树和森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">5.9.1.</span> <span class="toc-text">树的先根遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">5.9.2.</span> <span class="toc-text">树的后根遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.9.3.</span> <span class="toc-text">树的层次遍历(用队列实现)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.9.4.</span> <span class="toc-text">森林的先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.9.5.</span> <span class="toc-text">森林的中序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-14-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">5.10.</span> <span class="toc-text">5.14 二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">5.10.1.</span> <span class="toc-text">二叉树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.10.2.</span> <span class="toc-text">二叉排序树的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">5.10.3.</span> <span class="toc-text">二叉排序树的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">5.10.4.</span> <span class="toc-text">查找效率分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-15-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%80%89%E6%8B%A9%E9%A2%98"><span class="toc-number">5.11.</span> <span class="toc-text">5.15 平衡二叉树(选择题)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LL"><span class="toc-number">5.11.1.</span> <span class="toc-text">LL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RR"><span class="toc-number">5.11.2.</span> <span class="toc-text">RR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR"><span class="toc-number">5.11.3.</span> <span class="toc-text">LR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RL"><span class="toc-number">5.11.4.</span> <span class="toc-text">RL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-16-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">5.12.</span> <span class="toc-text">5.16 哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.12.1.</span> <span class="toc-text">哈夫曼的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">5.12.2.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">6.图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">6.2 邻接矩阵法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">6.3 邻接表法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">6.3.</span> <span class="toc-text">6.4 十字链表,邻接多重表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.</span> <span class="toc-text">6.5  图的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-BFS"><span class="toc-number">6.5.</span> <span class="toc-text">6.6 图的广度优先遍历(BFS)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-DFS"><span class="toc-number">6.6.</span> <span class="toc-text">6.7 深度优先遍历(DFS)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.7.</span> <span class="toc-text">6.8 最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-11-%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-number">6.8.</span> <span class="toc-text">6.9-11 图算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%9F%A5%E6%89%BE"><span class="toc-number">7.</span> <span class="toc-text">7.查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 查找的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 顺序查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 折半查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 分块查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-7-B%E6%A0%91"><span class="toc-number">7.5.</span> <span class="toc-text">7.5-7 B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-9-%E6%95%A3%E5%88%97"><span class="toc-number">7.6.</span> <span class="toc-text">7.8-9 散列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%8E%92%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">8.排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 排序的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E4%BB%A3%E7%A0%81%E9%87%8D%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">8.5 快速排序(代码重点)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.6.</span> <span class="toc-text">8.6 选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">8.7.</span> <span class="toc-text">8.7 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%A4%A7%E6%A0%B9%E5%A0%86"><span class="toc-number">8.7.1.</span> <span class="toc-text">建立大根堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A0%B9%E5%A0%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">8.7.2.</span> <span class="toc-text">基于大根堆进行排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-number">8.8.</span> <span class="toc-text">8.8 堆的插入删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">8.9.</span> <span class="toc-text">8.9 归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">8.10.</span> <span class="toc-text">8.10 基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-11-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">8.11.</span> <span class="toc-text">8.11 外部排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-12-%E8%B4%A5%E8%80%85%E6%A0%91%E2%80%94%E9%80%89%E5%87%BA%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0log2-k%E6%AC%A1"><span class="toc-number">8.12.</span> <span class="toc-text">8.12 败者树—选出最小元素log2 k次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-13-%E7%BD%AE%E6%8D%A2%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-r%E2%86%93"><span class="toc-number">8.13.</span> <span class="toc-text">8.13 置换—选择排序 r↓</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-14-%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">8.14.</span> <span class="toc-text">8.14 最佳归并树</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 61
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href= "/2023/09/08/poc-collection/" >poc_collection</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span><a class="archive-post-title" href= "/2022/12/12/QVD-2022-46174-thinkphp%E5%A4%9A%E8%AF%AD%E8%A8%80RCE/" >QVD-2022-46174-thinkphp多语言RCE</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/06</span><a class="archive-post-title" href= "/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" >数据结构-王道考研复习笔记</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href= "/2020/09/23/RSA%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/" >RSA与费马小定理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href= "/2020/09/08/awd%E6%80%BB%E7%BB%93/" >awd总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span><a class="archive-post-title" href= "/2020/08/05/CyBRICS2020/" >CyBRICS2020</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/09</span><a class="archive-post-title" href= "/2020/07/09/%E6%B5%85%E8%B0%88phar%E6%96%87%E4%BB%B6%E5%9C%A8ctf%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" >浅谈phar文件在ctf中的应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2020/07/01/2020%E8%85%BE%E8%AE%AF%E7%8A%80%E7%89%9B%E9%B8%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8T-Star%E9%AB%98%E6%A0%A1%E6%8C%91%E6%88%98%E8%B5%9Bwp/" >2020腾讯犀牛鸟网络安全T-Star高校挑战赛wp</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/14</span><a class="archive-post-title" href= "/2020/06/14/nginx-php-vscode-xdebug/" >nginx-php-vscode-xdebug</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/2020/06/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%B5%99%E5%A4%A7%E7%89%88%E5%92%95%E5%92%95%E5%92%95%E4%BA%86/" >数据结构-浙大版咕咕咕了</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span><a class="archive-post-title" href= "/2020/01/16/from-img-to-xss/" >from_img_to_xss</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/26</span><a class="archive-post-title" href= "/2019/12/26/hash-hmac-php-bug/" >hash_hmac_php_bug</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/27</span><a class="archive-post-title" href= "/2019/08/27/%E4%BB%8E%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%8F%91%E7%8E%B0%E6%9C%AA%E5%AD%A6%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" >从面试中发现未学到的知识点</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/07</span><a class="archive-post-title" href= "/2019/08/07/hitcon-ctf-2017-ssrfme/" >hitcon-ctf-2017-ssrfme</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/04</span><a class="archive-post-title" href= "/2019/08/04/de1tactf2019_ssrf_me/" >de1tactf2019_ssrf_me</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/04</span><a class="archive-post-title" href= "/2019/08/04/thinkphp5-0-sql-injection%E5%88%86%E6%9E%90/" >thinkphp5.0_sql_injection分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href= "/2019/07/13/sql%E6%B3%A8%E5%85%A5/" >sql注入</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/12</span><a class="archive-post-title" href= "/2019/07/12/%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E6%95%B4%E7%90%86/" >快速查询整理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/15</span><a class="archive-post-title" href= "/2019/06/15/rbash%E9%80%83%E9%80%B8/" >rbash逃逸</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span><a class="archive-post-title" href= "/2019/05/23/vulhub-learning/" >vulhub-learning</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/14</span><a class="archive-post-title" href= "/2019/05/14/apache%E5%9F%BA%E4%BA%8E%E5%A4%9Aip%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE+%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/" >apache基于多ip的虚拟主机配置+文件服务器和账号密码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href= "/2019/05/05/pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" >pwn学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span><a class="archive-post-title" href= "/2019/04/11/2019%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91web/" >2019西湖论剑web</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/22</span><a class="archive-post-title" href= "/2019/03/22/Python%E8%84%9A%E6%9C%AC%E4%B8%8EMetasploit%E4%BA%A4%E4%BA%92%E6%89%B9%E9%87%8F%E4%BA%A7%E5%87%BAMS17_010_shell/" >Python脚本与Metasploit交互批量产出MS17_010 shell</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/05</span><a class="archive-post-title" href= "/2019/03/05/pentesterlab%E4%B8%ADxss+Code%20injection%E7%9A%84%E7%BB%83%E4%B9%A0/" >pentesterlab中xss+Code injection的练习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/22</span><a class="archive-post-title" href= "/2019/02/22/hgame2019%20%E9%83%A8%E5%88%86web-wp/" >hgame2019 部分web-wp</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/08</span><a class="archive-post-title" href= "/2019/02/08/phpMyAdmin%E6%8F%90%E6%9D%83/" >phpMyAdmin提权</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/27</span><a class="archive-post-title" href= "/2018/11/27/%E7%94%A8updatexml%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%87%BA2018nctf%20%E6%BB%B4!%E6%99%A8%E8%B7%91%E6%89%93%E5%8D%A1/" >用updatexml报错注入技术解出2018nctf 滴!晨跑打卡</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/18</span><a class="archive-post-title" href= "/2018/11/18/2018hctf%20web/" >2018hctf web</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2018/10/26/%E5%BC%82%E6%88%96%E7%9A%84%E7%A0%94%E7%A9%B6/" >异或的研究</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/17</span><a class="archive-post-title" href= "/2018/10/17/2018%E6%9D%AD%E7%94%B5%E5%85%AC%E6%B5%8Bctf%20writeup/" >2018杭电公测ctf writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/14</span><a class="archive-post-title" href= "/2018/10/14/'%E2%80%9C%E7%99%BE%E5%BA%A6%E6%9D%AF%E2%80%9D2017%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%AC%A2%E4%B9%90%E8%B5%9B%EF%BC%9A%20%20%E4%B8%80%E4%B8%AAip%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%BA%E4%BC%9A%EF%BC%8C%E5%93%88%E5%93%88%E5%93%88%E3%80%82'/" >百度杯2017年春秋欢乐赛</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2018/10/10/Centos7%20%E5%AE%9E%E7%8E%B0ngrok%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" >Centos7 实现ngrok内网穿透</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/08</span><a class="archive-post-title" href= "/2018/10/08/kali%20%E5%9F%BA%E6%9C%AC%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" >kali 基本软件安装</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href= "/2018/09/23/%E5%AE%89%E6%81%92%E6%9D%AF9%E6%9C%88misc1%20crc32%E7%A2%B0%E6%92%9E/" >2018安恒杯9月misc1 crc32碰撞</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href= "/2018/09/23/%E7%AC%AC%E4%B8%80%E5%B1%8A%E7%99%BE%E5%BA%A6%E6%9D%AF%20upload/" >第一届百度杯 upload</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2018/09/20/wanna-to-see-your-hat-writeup/" >wanna to see your hat? writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/16</span><a class="archive-post-title" href= "/2018/09/16/centos7%20django+uwsgi+nginx%E9%85%8D%E7%BD%AE/" >centos7 django+uwsgi+nginx配置</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2018/09/13/HITCON2017(babyfirst-revenge)%20writeup/" >HITCON2017(babyfirst-revenge) writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2018/09/10/centos%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85/" >centos常见服务安装</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/23</span><a class="archive-post-title" href= "/2018/08/23/%E5%8D%97%E9%82%AEctf/" >南邮ctf</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/18</span><a class="archive-post-title" href= "/2018/08/18/Docker%E7%9A%84%E5%A4%A7%E5%9D%91%E8%AE%B0%E5%BD%95/" >Docker的大坑记录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span><a class="archive-post-title" href= "/2018/08/16/requests%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" >requests进行文件上传</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/12</span><a class="archive-post-title" href= "/2018/08/12/%E6%B5%85%E8%B0%88%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%90%8E%E7%BC%80%E6%A3%80%E6%B5%8B/" >浅谈文件上传的后缀检测</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href= "/2018/08/03/sql%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A11(mysqli_real_escape_string)/" >sql注入与防御1(mysqli_real_escape_string)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href= "/2018/07/23/%E5%AE%89%E6%81%92%E6%9D%AF7%E6%9C%88/" >2018安恒杯7月</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href= "/2018/07/23/%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/" >远程命令注入</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/03</span><a class="archive-post-title" href= "/2018/07/03/kali%E8%8E%B7%E5%8F%96%E6%8C%81%E7%BB%AD%E6%80%A7%E5%90%8E%E9%97%A8shell/" >kali获取持续性后门shell</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/02</span><a class="archive-post-title" href= "/2018/07/02/ms17_010%E5%92%8Cms08-067%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/" >ms17_010和ms08-067实验笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/27</span><a class="archive-post-title" href= "/2018/06/27/javascript%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8F%98%E6%8D%A2/" >javascript实现图片变换</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href= "/2018/06/20/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%AA%E6%96%AD%E4%B8%8A%E4%BC%A0/" >php 文件上传漏洞之%00截断上传</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/centos6.4%E9%85%8D%E7%BD%AE%20httpd/" >centos6.4配置 httpd</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/centos6.4%E9%85%8D%E7%BD%AEdns%E6%9C%8D%E5%8A%A1%E5%99%A8/" >centos6.4配置dns服务器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/centos6.4%E9%85%8D%E7%BD%AEnfs/" >centos6.4配置nfs</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/centos6.4%E9%85%8D%E7%BD%AEsamba/" >centos6.4配置samba</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/centos6.4%E9%85%8D%E7%BD%AEtelnet/" >centos6.4配置telnet</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/centos6.4%E9%85%8D%E7%BD%AEvpn/" >centos6.4配置vpn</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/kali%E4%B8%8B%E7%9A%84wifi%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" >kali下的wifi渗透测试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/kali%E4%B8%8B%E7%9A%84wpscan%E7%A0%B4%E8%A7%A3wordpress/" >kali下的wpscan破解wordpress</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/windows%E5%92%8Clinux%E4%BA%92%E9%80%9A/" >windows和linux互通</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span><a class="archive-post-title" href= "/2018/06/17/%E5%AE%9E%E9%AA%8C%E5%90%A7web%E6%80%9D%E8%B7%AF/" >实验吧web思路</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="ctf"><span class="iconfont-archer">&#xe606;</span>ctf</span>
    
        <span class="sidebar-tag-name" data-tags="运维"><span class="iconfont-archer">&#xe606;</span>运维</span>
    
        <span class="sidebar-tag-name" data-tags="rubbish"><span class="iconfont-archer">&#xe606;</span>rubbish</span>
    
        <span class="sidebar-tag-name" data-tags="pwn"><span class="iconfont-archer">&#xe606;</span>pwn</span>
    
        <span class="sidebar-tag-name" data-tags="python"><span class="iconfont-archer">&#xe606;</span>python</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "iloveflag"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>


